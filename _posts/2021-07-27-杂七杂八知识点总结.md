---
layout: post
title:  杂七杂八知识点总结
date:   2021-07-27 9:22:35 +0300
image:  6.jpg
tags:   随笔
---

>记录一些突然想到的还不太清楚的东西，便于以后查看。
>
>由于往后内容越写越多，涉及面又确实很杂，所以本文不再更新，新内容会开新篇。
# 一、动态内存分配\释放
## 1、C
```c
# include <stdlib.h>
void *malloc(unsigned long size);
void free(void *p);
```
**malloc** 函数只有一个形参，并且是整型。该函数的功能是在内存的动态存储空间即堆中分配一个长度为size的连续空间。函数的返回值是一个指向所分配内存空间起始地址的指针，类型为 **void***型。
如果此函数未能成功地执行，如内存空间不足，则返回空指针 NULL。
**free** 函数无返回值，它的功能是释放指针变量 p 所指向的内存单元。此时 p 所指向的那块内存单元将会被释放并还给操作系统，不再归它使用。操作系统可以重新将它分配给其他变量使用。
malloc 和 free 一定要成对存在，一一对应。有 malloc 就一定要有 free，有几个 malloc 就要有几个 free，与此同时，每释放一个指向动态内存的指针变量后要立刻把它指向 NULL。
<br>
使用例
```c
int *p = (int *)malloc(sizeof(int));
*p = 10;
free(p);
```
<br>

## 2、C++
在 C++ 中，通过 new 运算符来实现动态内存分配，通过 delete 运算符来释放动态分配的内存空间。
如果要求分配的空间太大，操作系统找不到足够的内存来满足，那么动态内存分配就会失败，此时程序会拋出异常。
```cpp
//分配变量
T *p = new T;
/*这样的语句会动态分配出一片大小为 sizeof(T) 字节的内存空间，并且将该内存空间的起始地址赋值给 p。
其中，T 是任意类型名，p 是类型为 T* 的指针*/

//分配数组
T *p =new T[N];
/*其中，T 是任意类型名，p 是类型为 T* 的指针，N 代表“元素个数”，可以是任何值为正整数的表达式，
表达式中可以包含变量、函数调用等。这样的语句动态分配出 N × sizeof(T) 个字节的内存空间，
这片空间的起始地址被赋值给 p
*/

delete p; // 释放变量
delete[] p; // 释放数组
//p 是指向动态分配的内存的指针
```
<br>

使用例
```cpp
int *p = new int;
*p = 5;
delete p;

int *p = new int[20];
p[0] = 1;
delete[] p;
```
<br>

## 3、分配二维数组
根据基本的动态内存分配方法，一维数组的分配是很容易的。
分配一个含5个 int 型元素的数组：
```cpp
// C
int *p;
p = (int *)malloc(sizeof(int)*5);
free(p);

// C++
int *p;
p = new int[5];
delete[] p;
```
二维数组的分配相对麻烦一点。
分配一个 5 × 5 的二维数组：
```cpp
// 	C
int **p; // 首先定义一个二级指针
p = (int **) malloc(sizeof(int *)*5); // 分配5行
for(int i = 0; i < 5; i++) // 每行再分配5列
	p[i] = (int *) malloc(sizeof(int)*5);
free(p);

// C++
int **p;
p = new int*[5];
for(int i = 0; i < 5; i++)
	p[i] = new int[5];
delete[] p;
```
以此类推，三维也可以构建。
<br><br>
# 二、参数传递
以最常见的交换两个元素的代码为例说明
## 1、值传递
这种方式使用变量、常量、数组元素作为函数参数，实际是将实参的值复制到形参相应的存储单元中，即形参和实参分别占用不同的存储单元，这种传递方式称为“参数的值传递”或者“函数的传值调用”。

主调函数调用时给形参分配存储单元，把实参的值传递给形参，在调用结束后，形参的存储单元被释放，而形参值的任何变化都不会影响到实参的值，实参的存储单元仍保留并维持数值不变。

一句话总结：**操作的是形参，实参不改变**。

```c
void Swap(int x, int y)
{
    int tmp;
    tmp = x;
    x = y;
    y = tmp;
}
int main()
{
    int a=10;
    int b=20;
    Swap(a, b);
    return 0;
}
```
<br>

## 2、地址传递
这种方式使用数组名或者指针作为函数参数，传递的是该数组的首地址或指针的值，而形参接收到的是地址，即指向实参的存储单元，形参和实参占用相同的存储单元，这种传递方式称为“参数的地址传递”。

地址传递的特点是形参并不存在存储空间，编译系统不为形参数组分配内存。数组名或指针就是一组连续空间的首地址。因此在数组名或指针作函数参数时所进行的传送只是地址传送，形参在取得该首地址之后，与实参共同拥有一段内存空间，形参的变化也就是实参的变化。

一句话总结：**实参跟着形参变**。

```c
void Swap(int *x, int *y)
{
    int tmp;
    tmp = *x;
    *x = *y;
    *y = tmp;
}
int main()
{
    int a=10;
    int b=20;
    Swap(&a, &b);
    return 0;
}
```
<br>

## 3、引用传递
我们常常想要对实参进行操作，也就是采用地址传递的方式，但也可以看到C语言里面地址传递中的指针操作会比较麻烦。不过好在我们大可不必使用纯C语言，因此可以考虑使用C++中引入的引用传递。

引用变量是变量的另一个别名，它没有自己的存储数据的内存位置，它访问的是另一个变量的内存位置。对引用变量作出的任何更改，实际上都是对它所引用的变量内存位置中存储数据的更改。

当使用引用变量作为形参时，它将变为实参列表中相应变量的别名，对形参进行的任何更改都将真正更改正在调用它的函数中的变量。当以这种方式将数据传递给形参时，该实参被称为按引用传递。

引用变量的定义方法和常规变量类似，但是其数据类型和名称之间有一个 & 符号

一句话总结：**引用变量为别名，访问的是原变量**。

```cpp
void Swap(int &x, int &y)
{
    int tmp;
    tmp = *x;
    *x = *y;
    *y = tmp;
}
int main()
{
    int a=10;
    int b=20;
    Swap(a, b);
    return 0;
}
```
<br>

## 4、数组作为函数参数
以上主要讨论参数为变量的情况，当参数为数组时，虽然本质上没有什么区别，但是在形式上会有所差距。

数组是一系列数据的集合，无法通过参数将它们一次性传递到函数内部，如果希望在函数内部操作数组，必须传递数组指针。

以求数组中最大元素的代码为例讨论。

### 形式1
类似地址传递，实参 nums 即数组首地址，形参用一个指针接收。

```c
int max(int *intArr, int len){
    int i, maxValue = intArr[0]
    for(i=1; i<len; i++){
        if(maxValue < intArr[i]){
            maxValue = intArr[i];
        }
    }

    return maxValue;
}
int main(){
    int nums[6], i;
    int len = sizeof(nums)/sizeof(int);
    for(i=0; i<len; i++){
        scanf("%d", nums+i);
    }
    printf("Max value is %d!\n", max(nums, len));
    return 0;
}
```
<br>

### 形式二
形参以数组的形式给出。
```c
int max(int intArr[6], int len){
    int i, maxValue = intArr[0];  //假设第0个元素是最大值
    for(i=1; i<len; i++){
        if(maxValue < intArr[i]){
            maxValue = intArr[i];
        }
    }
    return maxValue;
}
```
<br>

### 形式三
事实上，可以省略形式二中的数组长度。

```c
int max(int intArr[], int len){
    int i, maxValue = intArr[0];  //假设第0个元素是最大值
    for(i=1; i<len; i++){
        if(maxValue < intArr[i]){
            maxValue = intArr[i];
        }
    }
    return maxValue;
}
```
<br>

总之，由于函数调用时传入的都是数组名（即数组首元素地址），所以函数中的操作都是对原数组的操作。
<br>

### 补充
不管是int intArr[6]还是int intArr[]都不会创建一个数组出来，编译器也不会为它们分配内存，实际的数组是不存在的，它们最终还是会转换为int *intArr这样的指针。

需要强调的是，**不管使用哪种方式传递数组，都不能在函数内部求得数组长度**，因为 intArr 仅仅是一个指针，而不是真正的数组，所以必须要额外增加一个参数来传递数组长度。
<br>

### 二维数组作为函数参数
以上讨论的都是一维数组，那么如果参数为二维数组又会如何？
首先，将二维数组作为参数时，在形参声明中一定要指明数组的列数。这个应该是由于计算机中数组是按行优先进行存储的，所以有`a[i][j] = a[ i * COLNUM + j ]`，也就是必须给出列数才能计算出每一个数组元素的地址。（当然行一起给也行）

虽然以下总结了3种方法，不过个人认为第一种最为简单易用。
<br>
#### 形式1
参数声明为一个二维数组，其中一定要指定二维数组的列数。（注意列数不能为变量，否则相当于没指定）

```c
void f(int a[][3])
```
#### 形式2
把参数声明为一个指向一维数组的指针。（形式1本质上也是指向一个指向一维数组的指针）

```c
void f(int (*a)[3], int m, int n) {
    int i = 1;
    int j = 1;
    printf("a[%d][%d]=%d\n", i, j, a[i][j]);
}

int main() {
    int a[2][3] = {
        {1,2,3},
        {4,5,6}
    };
    f(a, 2, 3);
}
```
#### 形式3
把参数声明为指向指针的指针。

```c
void f(int **a, int m, int n) {
    int i = 1;
    int j = 1;
    printf("a[%d][%d]=%d\n", i, j, a[i][j]);
}

int main() {
    int a[2][3] = {
        {1,2,3},
        {4,5,6}
    };
    int * p[3];

    p[0] = a[0];
    p[1] = a[1];
    p[2] = a[2];
    f(p, 2, 3);
}
```
如果创建二维数组时是利用上面提到过的动态分配方式的话，则形参声明为二级指针，直接传入实参即可。
<br><br>

# 三、结构体
## 1、结构体定义
```cpp
struct 结构体名{
    结构体所包含的变量或数组
};
//结构体成员的定义方式与变量和数组的定义方式相同，只是不能初始化。
struct stu{
    char *name;  //姓名
    int num;  //学号
    int age;  //年龄
    char group;  //所在学习小组
    float score;  //成绩
};
```
<br>

## 2、结构体变量
```cpp
struct stu stu1, stu2;
```
也可以在定义结构体的同时定义结构体变量

```cpp
struct stu{
    char *name;  //姓名
    int num;  //学号
    int age;  //年龄
    char group;  //所在学习小组
    float score;  //成绩
} stu1, stu2;
```
<br>

## 3、typedef
说到结构体，就不得不提 typedef 。前面说到，定义结构体变量时使用 `struct stu stu1, stu2;` ，并且这个地方不能直接写成 `stu stu1, stu2` ，stu 前的 struct 不能省略。

C语言允许用户使用 typedef 关键字来定义自己习惯的数据类型名称，来替代系统默认的基本类型名称、数组类型名称、指针类型名称与用户自定义的结构型名称、共用型名称、枚举型名称等。一旦用户在程序中定义了自己的数据类型名称，就可以在该程序中用自己的数据类型名称来定义变量的类型、数组的类型、指针变量的类型与函数的类型等。
比如

```cpp
typedef struct stu{
    char *name;  //姓名
    int num;  //学号
    int age;  //年龄
    char group;  //所在学习小组
    float score;  //成绩
} stu1;
```
往后就可以直接使用 stu1 来指代 struct stu 这个结构体类型了。
<br>

同样的方法可以用来定义指向结构体自己的指针：

```cpp
// 1
typedef struct tagNode
{
    char *pItem;
    struct tagNode *pNext;
} *pNode;
// 2
struct tagNode
{
    char *pItem;
    struct tagNode *pNext;
};
typedef struct tagNode *pNode;
```
<br><br>

# 四、左值、右值
指赋值表达式的左、右
## 1、左值（变量名）
左值是用来指明一个对象的表达式。最简单的左值就是变量名称。左值（lvalue）之所以称为“左”（以首字母为 L，代表 left），是因为一个左值表示一个对象，它可以出现在赋值运算符（assignment operator）的左边，例如“左表达式=右表达式”。
## 2、右值（值）
其他表达式（那些表示一个值但不指明一个对象的），被类似地称为右值（rvalue）。右值是可以出现在赋值运算符右边而不是左边的表达式。例如，常量和算术表达式。
<br><br>

# 五、static\const\define 关键字
## 1、static
在 C 语言中，static 关键字可以用来修饰变量，也可以用来修饰函数。在使用 static 关键字修饰变量时，我们称此变量为静态变量。

```cpp
static int x;
```

### 隐藏与隔离的作用
对于一个全局变量，它的作用域是整个源程序，也就是在各个源文件中都是有效的。但是如果在全局变量前加上 static 即可限制其作用域只在定义该变量的源文件内有效，而在同一源程序的其他源文件中不能使用。
### 保持变量内容的持久性
有时候，我们希望函数中局部变量的值在函数调用结束之后不会消失，而仍然保留其原值。即它所占用的存储单元不释放，在下一次调用该函数时，其局部变量的值仍然存在，也就是上一次函数调用结束时的值。这时候，我们就应该将该局部变量用关键字 static 声明为“静态局部变量”。

静态局部变量和全局变量很相似，它们都存放在静态存储区，其区别在于可见性，静态局部变量只在其被声明的代码块中是可见的。

静态局部变量是在编译时赋初值的，且只赋初值一次。

**初值为0**。在静态数据区，内存中所有的字节默认值都是 0x00。静态变量与全局变量也一样，它们都存储在静态数据区中，因此其变量的值默认也为 0。演示示例如下所示。
<br>

## 2、const
定义只读变量的关键字，或者说 const 是定义常变量的关键字。

```cpp
const  int  a = 10;
int  const  a = 10;
// 二者都是可以的
```

用 const 定义的变量的值是不允许改变的，即不允许给它重新赋值，即使是赋相同的值也不可以。所以说它定义的是只读变量。这也就意味着必须在定义的时候就给它赋初值。

用 const 修饰的变量，无论是全局变量还是局部变量，生存周期都是程序运行的整个过程。全局变量的生存周期为程序运行的整个过程这个是理所当然的。而使用 const 修饰过的局部变量就有了静态特性，它的生存周期也是程序运行的整个过程。我们知道全局变量是静态的，静态的生存周期就是程序运行的整个过程。但是用const修饰过的局部变量只是有了静态特性，并没有说它变成了静态变量。
<br><br>

## 3、define
C语言中，可以用 #define 定义一个标识符来表示一个常量。其特点是：定义的标识符不占内存，只是一个临时的符号，预编译后这个符号就不存在了。

```cpp
#define  标识符  常量   //注意, 最后没有分号
```
#define 的作用域为自 #define 那一行起到源程序结束。如果要终止其作用域可以使用 #undef 命令，格式为：

```cpp
#undef  标识符
```
<br><br>

# 六、C++ sort()函数
sort() 函数是基于快速排序实现的，故该函数实现排序的平均时间复杂度为 $n*lgn$ 。
sort() 位于 algorithm 头文件中，因此在使用该函数前，需要先包含头文件

```cpp
#include <algorithm>
```

**sort (first, last)**	对容器或普通数组中 **[first, last)** 范围内的元素进行排序，默认进行升序排序。（ sort() 的结果是不稳定的）

**stable_sort (first, last)**	和 sort() 函数功能相似，不同之处在于，对于 [first, last) 范围内值相同的元素，该函数不会改变它们的相对位置。（ stable_sort() 的结果是稳定的）

sort() 函数有 2 种用法，其语法格式分别为：

```cpp
//对 [first, last) 区域内的元素做默认的升序排序
void sort (RandomAccessIterator first, RandomAccessIterator last);
//按照指定的 comp 排序规则，对 [first, last) 区域内的元素进行排序
void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp);
```
其中 comp 可以是 C++ STL 标准库提供的排序规则，也可以是自定义的排序规则（定义一个具有 2 个参数并返回 bool 类型值的函数作为排序规则。想按什么情况来排序，就在这种情况下返回true）。

通过自定义 comp 函数，除了可以对基本数组进行排序，还可以对结构体进行排序。
<br><br>

# 七、基本数据类型
基本数据类型所占位数及表示范围：
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/59393b93e1091691ab5158d0758cbd2e.png#pic_center)
对于整型/字符型没有什么需要特别强调的，根据其所占字节数即可导出其表示范围。
但是对于实型数据，由于其存储方式的不同，所以计算过程有所差异，这部分类容将在下一节详细讨论。
<br><br>

# 八、浮点数存储
在上一节说到，实型 ( float , double ) 的存储方式与整型不同，所以在计算其表示范围之前还需要了解浮点数在计算机中的存储方式。
浮点数实际上就是二进制的科学计数法，阶码指科学计数法中的指数，尾数指科学计数法中小数点之后的部分。

无论是单精度还是双精度在存储中都分为三个部分：
**1、符号位(Sign)** : 0代表正，1代表为负
**2、（阶码）指数位（Exponent）**:用于存储科学计数法中的指数数据，并且采用移码存储。表示它要乘以2的多少次方（二进制的小数点要向左或向右移动几位）
**3、（二进制表示）尾数部分（Mantissa）**：尾数部分 1.bbbbb…… 。表示它的二进制数字是哪些（除去整数部分的 1，原因是所有的数字表示成二进制科学计数法其整数部分都是 1 ，故可以省略，但是实际计算的时候是要加上的）。
![在这里插入图片描述](https://img-blog.csdnimg.cn/c20091d683d9471c884427bf900b2c81.jpg#pic_center)
那么已知一个浮点数的上述三种信息，如何计算其值就是显而易见的了：
![在这里插入图片描述](https://img-blog.csdnimg.cn/17d6896c0b3d440ca0ba08b635bbd7dd.jpg#pic_center)
![在这里插入图片描述](https://img-blog.csdnimg.cn/88be81c5cc9041f8bc226bae56e4e997.png#pic_center)

> 注：
> float 和 double 的存储方式分别为：
> float 符号 1位 指数 8位 尾数 23位
> double 符号1位 指数 11位 尾数 52位

经过上面的讨论，不难看出 M 和 E 实际就决定了浮点数的范围，下面分别说明。

**双精度浮点数**：
一位符号位 S
11位指数位 E ( 移码表示，范围为：E = -1024 到 1023 ）
52位尾数位 M
共计64位，8个字节
尾数 M 最大为 2 （记住要考虑省略的整数部分 1 ），指数 E 最大为 1023；
尾数 M 最小为 -2 （记住要考虑省略的整数部分 1 ），指数 E 最大为 1023；
最小数约等于 $-2*2^{1023}=-2^{1024}$
最大数约等于 $2*2^{1023}=2^{1024}$
当然，另有规定全0时代表0
所以 double 表示范围为 $-1.7e^{308}$ —— $1.7e^{308}$

**单精度浮点数**：
一位符号位 S
8位指数位 E ( 移码表示，范围为：E = -128 到 127 ）
23位尾数位 M
共计32位，4个字节
尾数 M 最大为 2 （记住要考虑省略的整数部分 1 ），指数 E 最大为 127；
尾数 M 最小为 -2 （记住要考虑省略的整数部分 1 ），指数 E 最大为 127；
最小数约等于：$-2*2^{127}=-2^{128}$
最大数约等于：$2*2^{127}=2^{128}$
所以 float 表示范围为 $-3.4e^{38}$ —— $3.4e^{38}$
<br><br>
